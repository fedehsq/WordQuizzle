package gui;
import common.UtilityClass;
import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.io.IOException;
import java.util.StringTokenizer;

public class WaitRequestGUI {
    private JLabel waitingJLabel;
    private JPanel waitingJPanel;
    private ClientGUI client;
    private JFrame waitingJFrame;
    private JFrame mainShellJFrame;


    public WaitRequestGUI(ClientGUI client, JFrame mainShellJFrame) {
        /*
        la shell principale rimarra' non visibile fino a che
        la richiesta non verra' accettata e quindi il game finito,
        oppure rifiutata
        */
        this.mainShellJFrame = mainShellJFrame;
        mainShellJFrame.setVisible(false);

        this.client = client;
        waitingJFrame = new JFrame("Quizzle");
        waitingJFrame.setContentPane(waitingJPanel);
        waitingJFrame.pack();
        waitingJFrame.setVisible(true);
        waitingJFrame.setResizable(false);
        waitResponse();
    }

    private void waitResponse() {
        // messaggio d'attesa che illustra i secondi prima della scadenza della richiesta
        Thread t = new Thread(new Thread(() -> {
            for (long s = UtilityClass.T1; s > 0; s -= 1000) {
                // se interrotto prima dello scadere, l'amico ha accettato
                if (!Thread.currentThread().isInterrupted()) {
                    waitingJLabel.setText("In attesa di accettazione, tempo rimasto: " + s / 1000 + " secondi");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        // interrotto se l'amico accetta
                        return;
                    }
                }
            }
        }));
        t.start();


        /*
         sospendo finché non arriva l'esito dall'amico, oppure lo scadere del timeout.
         mi verra' comunicato l'esito dal server, necessario creare un nuovo thread per questo task
         altrimenti il thread principale andrebbe in wait sulla readLine e non vedrei il tempo rimanente
         */
        new Thread(() -> {
            try {
                // attende che il server  comunichi se l'amico accetta o se scade il timeout
                String s = client.getIn().readLine();

                // interrompe il thread che calcola il timer di attesa (se è scaduto il timeout questa interrupt non ha effetto)
                t.interrupt();
                // chiudo il frame d'attesa
                waitingJFrame.setVisible(false);
                waitingJFrame.dispose();
                // se l'amico ha accettato, inzia la sfida
                if (s.contains("ha accettato,")) {
                    // invio messaggio al server che fa partire la sfida
                    String friend = new StringTokenizer(s).nextToken();
                    client.getOut().writeUTF("start " + friend);
                    // apro il frame del game
                    client.gameGui(mainShellJFrame);
                    // inizia la sfida
                    client.game();
                } else {
                    JOptionPane.showMessageDialog(new JFrame(), s, "Quizzle", JOptionPane.ERROR_MESSAGE);
                    // torno alla shell
                    mainShellJFrame.setVisible(true);
                }

            } catch (IOException e) {
                e.printStackTrace();
            }
        }).start();

    }

    {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        $$$setupUI$$$();
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private void $$$setupUI$$$() {
        waitingJPanel = new JPanel();
        waitingJPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 1, new Insets(30, 0, 30, 100), -1, -1));
        waitingJPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createLoweredBevelBorder(), "Sfida", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, null, new Color(-15578693)));
        waitingJLabel = new JLabel();
        waitingJLabel.setText("In attesa di accettazione, tempo rimasto:");
        waitingJPanel.add(waitingJLabel, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST, com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));
    }

    /**
     * @noinspection ALL
     */
    public JComponent $$$getRootComponent$$$() {
        return waitingJPanel;
    }
}
